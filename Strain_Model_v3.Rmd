---
title: "Agent based model of occupational strain across project management frameworks."
author: "Rebecca Folmer Schade"
date: "3 maj 2020"
output:   
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Quick notes about organisation 

The first 4 code chuncks define functions necesary for running the model. 
Above each function there is a short description of how the function is used in the simulation as well as an explantion the input for each function. 
To run the model, define each function in order of appearance as the last function, Simulation(), is dependent on the rest.
The code to run the model can be found in the second-to-last code chunk.


## Specs() function

Specs() checks for drift in specifications and imposes a penalty on the simulation if the drift is over a certain threshold. It also chnages the specifications.

- threshold = the max distance agent_specs can drift from model_specs
- array = array containing information about agents
- df = dataframe with information not connected to a specific agent
- turn = current turn in the model (which row in the array should the function)
- Penalty = the size of the penalty for project breakdown - a percentege of reduction in reward for each agent
- no = the probability of no change in scope 
- pos = the probability of a positive change in scope
- neg = the probability of a negative change in scope
- beta = the moderator of the effect of the effort/rewards ratio on mental health
- odds = odds ratio detailing the increase in strain

```{r}
# First we have to load some packages
pacman::p_load(pacman, tidyverse, truncnorm, groupdata2, gtools)

# Then we can define the first function 
Specs <- function(threshold, arrai, df, turn, penalty, no, pos, neg, beta, odds){
  # Checking if agent_specs has drifted
  spec_drift <- abs(df[turn-1,1] - df[turn-1,2])
  # This happens if agent_specs has drifted
  if(spec_drift >= threshold){
    # Penalty
    df[turn, 4] <- 1
    # ensuring that no reward score goes below 1 and calulating strain with penalty
    for(i in 1:dim(arrai)[3]){
      arrai[turn,3,i] <- arrai[turn-1,3,i] - abs((arrai[turn-1, 3,i]*penalty))
      if(arrai[turn, 3, i] < 1){
        arrai[turn, 3, i] <- 1
      }
      arrai[turn,4,i] <- log(arrai[turn,2,i]/arrai[turn,3,i])
      arrai[turn,5,i] <- arrai[turn-1,5,i] + (beta * arrai[turn,4,i] * log(odds))
    }
    # Agent_specs are adapted to model_specs  
    df[turn, 2] <- df[turn-1, 1]
  }
  
  # Deciding if model_specs should be changed
  spec_change <- sample(c("none", "positive", "negative"), 1, prob = c(no, pos, neg))
  # if spec_chance is positive, 1 is added to model_specs
  if(spec_change == "positive"){
    df[turn, 1] <- df[turn-1, 1] + 1
  }
  # if spec_chance is negative, 1 is subtracted from model_specs
  if(spec_change == "negative"){
    df[turn, 1] <- df[turn-1, 1] - 1
  }
  return(list(df, arrai))
}

```


## Sprint() Function

Sprint() keeps track of the sprints and changes the model specifications in the Complex condition. It is only used in the Scrum conditions. It should happen at the end of a loop. 

- len = the length of the sprint in turns
- df = dataframe with information not connected to a specific agent
- turn = current turn in the model (which row in the array should the function)

```{r}
Sprint <- function(len, df, turn){
  
  # This happens at the last turn of the sprint
  if(df[turn, 3] == len){
    # agent_specs moves closer to project_specs if agent_specs is greater  
    if(df[turn-1, 2] > df[turn-1, 1]){
      df[turn, 2] <- df[turn-1, 2] - 1
    }
    # agent_specs moves closer to project_specs if agent_specs is smaller
    if(df[turn-1, 2] < df[turn-1, 2]){
      df[turn-1, 2] <- df[turn-1, 2] + 1
    }
  }
  
  # Function returns changed agent_specs and sprint_turn
  return(df)
}

```


## Work() function 

The Work() function simulates the agents working on the project. It is used in all conditions. 

- colab_prob = the defaoult probablility of a sucessful collaboration (ie. not modefied by mental health yet)
- array = array containing information about agents
- turn = current turn in the model (which row in the array should the function)
- beta = the moderator of the effect of the effort/rewards ratio on mental health
- odds = odds ratio detailing the increase in strain
- s_beta = the moderator of the effect of strain on sucessrate

```{r}
Work <- function(colab_prob, arrai, turn, beta, odds, s_beta) {
  
  # For loop repeating for each participant
  for(i in 1:dim(arrai)[3]){
    
    # Defining the probability of a sucessful collaboration
    s_prob <- arrai[turn,7,i] + (inv.logit(arrai[turn-1,5,i]) * s_beta)

    # Determining if the collaboration is sucessful
    colab <- sample(c("sucess", "fail"), 1, prob = c(s_prob,(1-s_prob)))
    
    # Simulating collaboration
    if(colab == "sucess"){
      eff <- rtruncnorm(1, a=1, b=1.05, mean = 1.04, sd = 0.02)
      rew <- rtruncnorm(1, a=1.05, b=1.10, mean = 1.07, sd = 0.02)
      arrai[turn,1,i] <- 1
      arrai[turn,2,i] <- arrai[turn-1,2,i] * eff
      arrai[turn,3,i] <- arrai[turn-1,3,i] * rew
      arrai[turn,4,i] <- log(arrai[turn,2,i]/arrai[turn,3,i])
      strain <- arrai[turn,6,i] + (beta * arrai[turn,4,i] * log(odds))
      arrai[turn,5,i] <- rnorm(1, mean = strain, sd = 0.01)
    } else {
      eff <- rtruncnorm(1, a=1.05, b=1.10, mean = 1.07, sd = 0.02)
      rew <- rtruncnorm(1, a=1, b=1.05, mean = 1.04, sd = 0.02)
      arrai[turn,2,i] <- arrai[turn-1,2,i] * eff
      arrai[turn,3,i] <- arrai[turn-1,3,i] * rew
      arrai[turn,4,i] <- log(arrai[turn,2,i]/arrai[turn,3,i])
      strain <- arrai[turn,6,i] + (beta * arrai[turn,4,i] * log(odds))
      arrai[turn,5,i] <- rnorm(1, mean = strain, sd = 0.01)
    }
  }
  
  # Retuning the modifyed dataframe
  return(arrai)
}

```


## Simulation() function

The Simulation() function gathers all the Work(), Sprint() and Specs() functions to comute the agent based model. 

- n_turns = the number of turns simulated 
- n_agent = the number of agents
- start_prob = the initial sucessrate (unmodulated by mental_health) of all the agents
- scrum = Scrum condition or not Scrum condition
- specs = specifying if the scope is changing or static
- threshold = the max distance agent_specs can drift from model_specs
- len = the length of the sprint in turns
- Penalty = the size of the penalty for project breakdown - a percentege of reduction in reward for each agent
- no = the probability of no change in scope 
- pos = the probability of a positive change in scope
- neg = the probability of a negative change in scope
- beta = the moderator of the effect of the effort/rewards ratio on mental health
- odds = odds ratio detailing the increase in strain
- s_beta = the moderator of the effect of strain on sucessrate

```{r}
Simulation <- function(n_turns, n_agent, start_prob, threshold, len, penalty, no, pos, neg, beta, odds, s_beta){
  
  # Making an array containing information about all agents
  agents <- array(0,c(n_turns,7,n_agent))
  dimnames(agents)[[2]] <- c("sucess", "effort", "reward", "ratio", "strain", "baseline", "sucess_rate")
  # Setting baseline for strain
  for(i in 1:n_agent){
    agents[,6,i] <- rnorm(1, mean=-1.386294, sd=0.01)
  }
  # Setting sucessrate for each agent
  for(i in 1:n_agent){
    agents[,7,i] <- rnorm(1, mean=0.50, sd=0.10)
  }
  # Making a dataframe with additional variables
  values <- tibble("project_specs" = rep.int(0,n_turns), 
                   "agent_specs" = rep.int(0,n_turns), 
                   "sprint_turn" = rep_len(1:len,n_turns), 
                   "breakdown" = rep.int(0,n_turns))
  
  #---> For the first turn 
  # The first turn is alway the first turn in an interval.
  for(i in 1:n_agent){
    eff <- rtruncnorm(1, a=1.05, b=1.10, mean = 1.07, sd = 0.02)
    rew <- rtruncnorm(1, a=1, b=1.05, mean = 1.04, sd = 0.02)
    agents[1,2,i] <- 1 * eff
    agents[1,3,i] <- 1 * rew
    agents[1, 4, i] <- log(agents[1, 2, i]/agents[1, 3, i]) # calculating the ER ratio
    strain <- agents[1,6,i] + (beta * agents[1, 4, i] * log(odds))
    agents[1, 5, i] <- rnorm(1, mean = strain, sd = 0.01)
  }

  # Deciding if model_specs should be changed
  spec_change <- sample(c("none", "positive", "negative"), 1, prob = c(no, pos, neg))
  # if spec_chance is positive, 1 is added to model_specs
  if(spec_change == "positive"){
    values[1,1] <- 1
  }
  # if spec_chance is negative, 1 is subtracted from model_specs
  if(spec_change == "negative"){
    values[1,1] <- (- 1)
  }
  
  #----> For loop for repeating repeating the same procedure for the rest of the turns
  for(i in 2:n_turns){
    # work is siulated and agent_frame is updated
    agents <- Work(start_prob, agents, i, beta, odds, s_beta)
    
    # Sprints are simulated and values are udpated
    values <- Sprint(len, values, i)
    
    # Spacs are changed and both agent_frame and values are updated
    both <- Specs(threshold, agents, values, i, penalty, no, pos, neg, beta, odds)
    values <- both[[1]]
    agents <- both[[2]]
    
  }
  
  # Retun an array with information about participants 
  return(list(values, agents))
}

```


## Use this code to run the model!
The model has 4 different conditions - each one is run with it's own iteration of the Simulation function.

```{r}
# Condition 1: Short intervals, low rate of change in scope
cond1 <- Simulation(n_turns = 100,
                    n_agent = 5,
                    start_prob = 0.50,
                    threshold = 2,
                    len = 5, # the parameter that decides the interval condition.
                    penalty = 0.05,
                    no = 0.8, #---|These three parameters decide the scope condition.
                    pos = 0.1, #--|
                    neg = 0.1, #--|
                    beta = 0.5,
                    odds = 1.49,
                    s_beta = -0.5)

# Condition 2: Short intervals, high rate of change in scope
cond2 <- Simulation(n_turns = 100,
                    n_agent = 5,
                    start_prob = 0.50,
                    threshold = 2,
                    len = 5, # the parameter that decides the interval condition.
                    penalty = 0.05,
                    no = 0.6, #---|These three parameters decide the scope condition.
                    pos = 0.2, #--|
                    neg = 0.2, #--|
                    beta = 0.5,
                    odds = 1.49,
                    s_beta = -0.5)

# Condition 3: long intervals, low rate of change in scope
cond3 <- Simulation(n_turns = 100,
                    n_agent = 5,
                    start_prob = 0.50,
                    threshold = 2,
                    len = 20, # the parameter that decides the interval condition.
                    penalty = 0.05,
                    no = 0.8, #---|These three parameters decide the scope condition.
                    pos = 0.1, #--|
                    neg = 0.1, #--|
                    beta = 0.5,
                    odds = 1.49,
                    s_beta = -0.5)

# Condition 4: long intervals, high rate of change in scope
cond4 <- Simulation(n_turns = 100,
                    n_agent = 5,
                    start_prob = 0.50,
                    threshold = 2,
                    len = 20, # the parameter that decides the interval condition.
                    penalty = 0.05,
                    no = 0.6, #---|These three parameters decide the scope condition.
                    pos = 0.2, #--|
                    neg = 0.2, #--|
                    beta = 0.5,
                    odds = 1.49,
                    s_beta = -0.5)

# To check if I get a result
twodf[[1]]
twodf[[2]][,,5]

```


## Plots
The code for the plots used in the prose for the exam assigment can be found here: 

```{r}
# Plot of the sumilation 
df <- tibble("turn" = 1:100,"agent_1" = twodf[[2]][, 5, 1], "agent_2" = twodf[[2]][, 5, 2], "agent_3" = twodf[[2]][, 5, 3], "agent_4" = twodf[[2]][, 5, 4], "agent_5" = twodf[[2]][, 5, 5], "breakdown" = as.factor(twodf[[1]][,4]$breakdown))


#df[,8] <- c(rep(1,5), rep(2,5), rep(3,5), rep(4,5), rep(5,5), rep(6,5), rep(7,5), rep(8,5), rep(9,5), rep(10,5), rep(11,5), rep(12,5), rep(13,5), rep(14,5), rep(15,5), rep(16,5), rep(17,5), rep(18,5), rep(19,5), rep(20,5))

#df <- df %>% group_by(V8) %>% dplyr::summarise(agent_1 = mean(agent_1), agent_2 = mean(agent_2), agent_3 = mean(agent_3), agent_4 = mean(agent_4), agent_5 = mean(agent_5))

#df <- df %>% slice(rep(1:n(), each = 5))
#df$turn <- 1:100 
#df$breakdown <- as.factor(twodf[[1]][,4]$breakdown)

df_wide <- gather(df, key = "agent", value = "strain", agent_1:agent_5)

ggplot(df_wide, aes(x = turn, y = strain, color = agent)) + geom_line(size = 1) + geom_vline(data = df_wide %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

# Plot of the sumilation in percenteges 
# Function fro conversion that I might not need:
inv.logit <- function(logit){
  odds <- exp(logit)
  prob <- odds / (1 + odds)
  return(prob)
}
# making dataframe 
df_p <- tibble("turn" = 1:100,"agent_1" = inv.logit(twodf[[2]][, 5, 1]), "agent_2" = inv.logit(twodf[[2]][, 5, 2]), "agent_3" = inv.logit(twodf[[2]][, 5, 3]), "agent_4" = inv.logit(twodf[[2]][, 5, 4]), "agent_5" = inv.logit(twodf[[2]][, 5, 5]), "breakdown" = as.factor(twodf[[1]][,4]$breakdown))

df_wide_p <- gather(df_p, key = "agent", value = "strain", agent_1:agent_5)

ggplot(df_wide_p, aes(x = turn, y = strain, color = agent)) + geom_line(size = 1) + geom_vline(data = df_wide_p %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

#----

# Plot of the simulation but with ratio instead
df_r <- tibble("turn" = 1:100,"agent_1" = twodf[[2]][, 4, 1], "agent_2" = twodf[[2]][, 4, 2], "agent_3" = twodf[[2]][, 4, 3], "agent_4" = twodf[[2]][, 4, 4], "agent_5" = twodf[[2]][, 4, 5], "breakdown" = as.factor(twodf[[1]][,4]$breakdown))

df_wide_r <- gather(df_r, key = "agent", value = "ratio", agent_1:agent_5)

ggplot(df_wide_r, aes(x = turn, y = ratio, color = agent)) + geom_line(size = 1) + geom_vline(data = df_wide_r %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

# Plot of the simulation but with only reward
df_re <- tibble("turn" = 1:100,"agent_1" = twodf[[2]][, 3, 1], "agent_2" = twodf[[2]][, 3, 2], "agent_3" = twodf[[2]][, 3, 3], "agent_4" = twodf[[2]][, 3, 4], "agent_5" = twodf[[2]][, 3, 5], "breakdown" = as.factor(twodf[[1]][,4]$breakdown))

df_wide_re <- gather(df_re, key = "agent", value = "reward", agent_1:agent_5)

ggplot(df_wide_re, aes(x = turn, y = reward, color = agent)) + geom_line(size = 1) + geom_vline(data = df_wide_re %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

ggplot(df_wide_re, aes(x = turn, y = reward)) + geom_line(size = 1) + geom_vline(data = df_wide_re %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

# Average reward vs. average effort
re <- tibble("agent_1_re" = twodf[[2]][, 3, 1], "agent_2_re" = twodf[[2]][, 3, 2], "agent_3_re" = twodf[[2]][, 3, 3], "agent_4_re" = twodf[[2]][, 3, 4], "agent_5_re" = twodf[[2]][, 3, 5]) 

ef <- tibble("agent_1_ef" = twodf[[2]][, 2, 1], "agent_2_ef" = twodf[[2]][, 2, 2], "agent_3_ef" = twodf[[2]][, 2, 3],  "agent_4_ef" = twodf[[2]][, 2, 4], "agent_5_ef" = twodf[[2]][, 2, 5]) 

df_av <- tibble("turn" = 1:100, "effort" = rowMeans(ef), "reward" = rowMeans(re), "breakdown" = as.factor(twodf[[1]][,4]$breakdown))

df_wide_av <- gather(df_av, key = "variable", value = "score", reward, effort)

ggplot(df_wide_av, aes(x = turn, y = log(score), color = variable)) + geom_line(size = 1) + geom_vline(data = df_wide_av %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

# Numerical difference between effort and reward
df_num <- tibble("turn" = 1:100, "agent_1_re" = twodf[[2]][, 3, 1], "agent_2_re" = twodf[[2]][, 3, 2], "agent_3_re" = twodf[[2]][, 3, 3], "agent_4_re" = twodf[[2]][, 3, 4], "agent_5_re" = twodf[[2]][, 3, 5],"agent_1_ef" = twodf[[2]][, 2, 1], "agent_2_ef" = twodf[[2]][, 2, 2], "agent_3_ef" = twodf[[2]][, 2, 3],  "agent_4_ef" = twodf[[2]][, 2, 4], "agent_5_ef" = twodf[[2]][, 2, 5], "breakdown" = as.factor(twodf[[1]][,4]$breakdown)) %>% mutate("agent_1" = agent_1_ef - agent_1_re, "agent_2" = agent_2_ef - agent_2_re, "agent_3" = agent_3_ef - agent_3_re, "agent_4" = agent_4_ef - agent_4_re, "agent_5" = agent_5_ef - agent_5_re) %>% select(turn, agent_1, agent_2, agent_3, agent_4, agent_5, breakdown)

df_wide_num <- gather(df_num, key = "agent", value = "difference", agent_1:agent_5)

ggplot(df_wide_num, aes(x = turn, y = difference, color = agent)) + geom_line(size = 1) + geom_vline(data = df_wide_num %>% select(turn, breakdown) %>%  filter(breakdown == 1), aes(xintercept = turn), alpha = 0.5)

inv.logit(0.20)
```



















